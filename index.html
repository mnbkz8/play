<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>リバーシ</title>
  <style>
    body {
      text-align: center;
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #f4f4f4;
    }
    h1 {
      color: #2c3e50;
      margin-top: 0.5em;
    }
    table {
      border-collapse: collapse;
      margin: auto;
      width: 320px;
      height: 320px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    td {
      width: 40px;
      height: 40px;
      border: 1px solid #333;
      background: #8fbc8f;
      position: relative;
      box-sizing: border-box;
    }
    .disk {
      width: 80%;
      height: 80%;
      border-radius: 50%;
      position: absolute;
      top: 10%;
      left: 10%;
      box-shadow: inset 0 0 2px rgba(0,0,0,0.4);
      transition: transform 0.3s;
      transform-style: preserve-3d;
    }
    .black { background: #000; }
    .white { background: #fff; }
    .ghost {
      opacity: 0.2;
    }
    .count {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 0.6em;
      color: #d33;
      pointer-events: none;
    }
    .flipped {
      transform: rotateY(180deg);
    }
    #score {
      font-size: 1.2em;
      margin: 0.5em 0;
    }
    button {
      font-size: 1.1em;
      padding: 0.5em 1em;
      margin-top: 0.5em;
      background: #4caf50;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover {
      background: #43a047;
    }
    #message {
      color: #d33;
      min-height: 1.2em;
      margin: 0.5em;
    }
  </style>
</head>
<body>
  <h1>リバーシ（2人対戦）</h1>
  <div id="turn">黒の番です</div>
  <div id="score"></div>
  <div id="message"></div>
  <p>タップして石を置いてね</p>
  <table id="board"></table>
  <button id="reset">リセット</button>

  <script>
    const board = document.getElementById("board");
    const scoreEl = document.getElementById("score");
    const messageEl = document.getElementById("message");
    document.getElementById("reset").addEventListener("click", () => {
      board.innerHTML = "";
      init();
    });
    const size = 8;
    const EMPTY = 0, BLACK = 1, WHITE = 2;
    let current = BLACK;
    let grid = [];
    let audioCtx;

    function init() {
      board.innerHTML = "";
      grid = Array.from({length: size}, () => Array(size).fill(EMPTY));
      grid[3][3] = WHITE; grid[3][4] = BLACK;
      grid[4][3] = BLACK; grid[4][4] = WHITE;

      for (let y = 0; y < size; y++) {
        const row = board.insertRow();
        for (let x = 0; x < size; x++) {
          const cell = row.insertCell();
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.addEventListener("click", handleClick);
        }
      }
      render();
    }

    function render() {
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board.rows[y].cells[x];
          cell.innerHTML = '';
          if (grid[y][x] !== EMPTY) {
            const disk = document.createElement("div");
            disk.className = "disk " + (grid[y][x] === BLACK ? "black" : "white");
            cell.appendChild(disk);
          }
        }
      }

      const valid = getValidMoves(current);
      for (const [x, y] of valid) {
        const cell = board.rows[y].cells[x];
        const ghost = document.createElement("div");
        ghost.className =
          "disk ghost " + (current === BLACK ? "black" : "white");
        const cnt = document.createElement("div");
        cnt.className = 'count';
        cnt.textContent = countFlips(x, y, current);
        ghost.appendChild(cnt);
        cell.appendChild(ghost);
      }

      document.getElementById("turn").textContent =
        current === BLACK ? "黒の番です" : "白の番です";
      updateScore();
    }

    function handleClick(e) {
      const x = +e.currentTarget.dataset.x;
      const y = +e.currentTarget.dataset.y;
      if (!canPut(x, y, current)) return;
      const flips = put(x, y, current);
      playSound();
      current = current === BLACK ? WHITE : BLACK;

      if (getValidMoves(current).length === 0) {
        const other = current === BLACK ? WHITE : BLACK;
        if (getValidMoves(other).length === 0) {
          showWinner();
          render();
          return;
        } else {
          showMessage((current === BLACK ? '黒' : '白') + 'は置ける場所がありません。パスします');
          current = other;
        }
      }

      render();
      animateFlip([[x, y], ...flips]);
    }

    const dirs = [[1,0], [-1,0], [0,1], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]];

    function getValidMoves(color) {
      const moves = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (canPut(x, y, color)) moves.push([x, y]);
        }
      }
      return moves;
    }

  function getScore() {
    let b = 0, w = 0;
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        if (grid[y][x] === BLACK) b++;
        else if (grid[y][x] === WHITE) w++;
      }
    }
    return [b, w];
  }

  function updateScore() {
    const [b, w] = getScore();
    scoreEl.textContent = `黒:${b} 白:${w}`;
  }

  function showMessage(msg) {
    messageEl.textContent = msg;
    setTimeout(() => { messageEl.textContent = ''; }, 1500);
  }

  function countFlips(x, y, color) {
    if (grid[y][x] !== EMPTY) return 0;
    let total = 0;
    for (const [dx, dy] of dirs) {
      let nx = x + dx, ny = y + dy;
      let flips = 0;
      while (nx >= 0 && ny >= 0 && nx < size && ny < size) {
        if (grid[ny][nx] === EMPTY) { flips = 0; break; }
        if (grid[ny][nx] === color) break;
        flips++;
        nx += dx; ny += dy;
      }
      if (nx >= 0 && ny >= 0 && nx < size && ny < size && grid[ny][nx] === color) {
        total += flips;
      }
    }
    return total;
  }

  function playSound() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.value = 500;
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.2);
  }

    function canPut(x, y, color) {
      if (grid[y][x] !== EMPTY) return false;
      for (const [dx, dy] of dirs) {
        let nx = x + dx, ny = y + dy;
        let found = false;
        while (nx >= 0 && ny >= 0 && nx < size && ny < size) {
          if (grid[ny][nx] === EMPTY) break;
          if (grid[ny][nx] === color) {
            if (found) return true;
            else break;
          }
          found = true;
          nx += dx; ny += dy;
        }
      }
      return false;
    }

    function put(x, y, color) {
      grid[y][x] = color;
      const flipped = [];
      for (const [dx, dy] of dirs) {
        let nx = x + dx, ny = y + dy;
        const flip = [];
        while (nx >= 0 && ny >= 0 && nx < size && ny < size) {
          if (grid[ny][nx] === EMPTY) break;
          if (grid[ny][nx] === color) {
            for (const [fx, fy] of flip) {
              grid[fy][fx] = color;
              flipped.push([fx, fy]);
            }
            break;
          }
          flip.push([nx, ny]);
          nx += dx; ny += dy;
        }
      }
      return flipped;
    }

    function animateFlip(cells) {
      for (const [x, y] of cells) {
        const cell = board.rows[y].cells[x];
        const disk = cell.querySelector('.disk');
        if (disk) {
          disk.classList.add('flipped');
          requestAnimationFrame(() => disk.classList.remove('flipped'));
        }
      }
    }

    function showWinner() {
      const [b, w] = getScore();
      if (b === w) showMessage('引き分け');
      else showMessage(b > w ? '黒の勝ち!' : '白の勝ち!');
    }

    init();
  </script>
</body>
</html>
